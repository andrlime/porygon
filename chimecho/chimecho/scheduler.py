"""
Library to build a schedule.html file from Markdown templates

Generated by o3-mini 02/22/2025
"""

import logging
import os
import re
from typing import Any

from chimecho.config import AppConfig


def load_templates(folder: str) -> dict[str, str]:
    """
    Loads markdown templates matching "template-[dayName].md" from the folder.
    Returns a dictionary mapping day names (e.g., "Sunday") to file content.
    """
    templates = {}
    for filename in os.listdir(folder):
        m = re.match(r"template-(\w+)\.md", filename, re.IGNORECASE)
        if m:
            day_name = m.group(1).capitalize()
            filepath = os.path.join(folder, filename)
            with open(filepath, "r", encoding="utf-8") as f:
                content = f.read()
            templates[day_name] = content
    return templates


def process_template(content: str) -> list[dict[str, Any]]:
    """
    Processes each line from the template file.
    Expected formats:
      - [ ] 0900-0950 Orgo Lecture
      - [-] 1600-1620 James Meeting
      - [?] 1000-1050 Quantum Mechanics Lecture
      - [ ] 2230 ISP Soccer  (single time, uses default duration)

    Lines without a valid time, with an empty description (or "work"), or outside the 8amâ€“midnight range are skipped.

    Returns a list of dictionaries:
      { "start": int, "end": int, "duration": int, "desc": str, "type": str }
    """
    time_start, time_end, _, default_duration = AppConfig().get_yaml_values()

    tasks = []
    pattern = re.compile(r"^-\s*\[\s*([ \-\?xX])\s*\]\s*(\d{4})(?:-(\d{4}))?\s+(.+)$")
    for line in content.splitlines():
        raw_line = line
        line = line.strip()
        m = pattern.match(line)
        if not m:
            continue
        marker, start_str, end_str, desc = m.groups()
        desc = desc.strip()
        if not desc or desc.lower() == "work":
            logging.info("Skipped (empty or 'work'): %s", raw_line)
            continue
        try:
            start_minutes = int(start_str[:2]) * 60 + int(start_str[2:])
        except ValueError:
            logging.info("Skipped (invalid start): %s", raw_line)
            continue
        if end_str:
            try:
                end_minutes = int(end_str[:2]) * 60 + int(end_str[2:])
            except ValueError:
                logging.info("Skipped (invalid end): %s", raw_line)
                continue
            duration = end_minutes - start_minutes
        else:
            duration = default_duration
            end_minutes = start_minutes + default_duration
        if end_minutes <= start_minutes:
            logging.info("Skipped (end<=start): %s", raw_line)
            continue
        if start_minutes < time_start or end_minutes > time_end:
            logging.info("Skipped (outside range): %s", raw_line)
            continue
        if marker == "-":
            task_type = "cancelled"
        elif marker == "?":
            task_type = "tentative"
        else:
            task_type = "normal"
        logging.info(
            'Included: start=%s, end={end_str if end_str else "(+30min)"}, label="%s"',
            start_str,
            desc,
        )
        tasks.append(
            {
                "start": start_minutes,
                "end": end_minutes,
                "duration": duration,
                "desc": desc,
                "type": task_type,
            }
        )
    return tasks


def generate_week_html(templates: dict[str, str]) -> None:
    """
    Generates an HTML page for the weekly view.
      - The container fills 100vw x 100vh.
      - Each day occupies an equal-width column.
      - Task positions are computed based on time_start and a scale factor.
      - All event names are bold and are followed by a normal-weight time span.
      - The CSS is loaded from an external file (style.css).
    """
    time_start, time_end, min_duration, _ = AppConfig().get_yaml_values()
    _, schedule_label, container_height, output = AppConfig().get_cli_values()
    scale = container_height / (time_end - time_start)  # pixels per minute

    week_days = [
        "Sunday",
        "Monday",
        "Tuesday",
        "Wednesday",
        "Thursday",
        "Friday",
        "Saturday",
    ]

    html_parts = []
    html_parts.append("<html><head>")
    html_parts.append("<meta charset='utf-8'>")
    # Link to the external CSS file
    html_parts.append("<link rel='stylesheet' type='text/css' href='styles.css'>")
    html_parts.append("</head><body>")
    html_parts.append(f"<div class='schedule-label'>{schedule_label}</div>")
    html_parts.append("<div class='container'>")
    html_parts.append("<div class='week'>")
    for day in week_days:
        template_content = templates.get(day, "")
        tasks = process_template(template_content)
        html_parts.append("<div class='day-column'>")
        html_parts.append(f"<div class='day-header'>{day}</div>")
        html_parts.append("<div class='day-timeline'>")
        for task in tasks:
            # Ensure a minimum display duration of 30 minutes
            display_duration = (
                task["duration"] if task["duration"] >= min_duration else min_duration
            )
            top_px = (task["start"] - time_start) * scale
            height_px = display_duration * scale

            extra_class = ""
            if task["type"] == "cancelled":
                extra_class = " cancelled"
            elif task["type"] == "tentative":
                extra_class = " tentative"

            # Compute event time strings
            start_hour = task["start"] // 60
            start_min = task["start"] % 60
            end_hour = task["end"] // 60
            end_min = task["end"] % 60
            time_string_start = f"{start_hour:02d}:{start_min:02d}"
            time_string_end = f"{end_hour:02d}:{end_min:02d}"
            time_str = f"{time_string_start} - {time_string_end}\t"

            task_description = task["desc"]
            html_parts.append(
                f"<div class='task{extra_class}' style='top: {top_px}px; height: {height_px}px;'>"
                f"<span class='time-span'>{time_str}</span>"
                f"<strong>{task_description}</strong> "
                f"</div>"
            )
        html_parts.append("</div>")  # end day-timeline
        html_parts.append("</div>")  # end day-column
    html_parts.append("</div>")  # end week
    html_parts.append("</div>")  # end container
    html_parts.append("</body></html>")

    combined_html = "\n".join(html_parts)
    with open(f"{output}.html", "w", encoding="utf-8") as f:
        f.write(combined_html)
    logging.info("Weekly schedule generated as %s.html", output)
